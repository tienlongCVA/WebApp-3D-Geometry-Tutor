<!DOCTYPE html>
<html lang="vi">
<head>
  <meta charset="UTF-8" />
  <title>H√¨nh h·ªçc kh√¥ng gian 3D</title>
  <style>
    body {
      margin: 0;
      background: #000;
      color: white;
      font-family: Arial, sans-serif;
      overflow: hidden;
    }
    #info {
      position: absolute;
      top: 15px;
      left: 15px;
      background: rgba(20, 20, 20, 0.9);
      padding: 15px;
      border-radius: 10px;
      border: 1px solid #444;
      width: 270px;
    }
    label { display: block; margin-top: 6px; }
    input, select {
      width: 100%;
      margin-top: 4px;
      padding: 6px;
      border-radius: 5px;
      border: none;
      background: #222;
      color: white;
      font-size: 13px;
    }
    .switch {
      position: relative;
      display: inline-block;
      width: 45px;
      height: 24px;
    }
    .switch input { opacity: 0; width: 0; height: 0; }
    .slider {
      position: absolute;
      cursor: pointer;
      top: 0; left: 0; right: 0; bottom: 0;
      background-color: #555;
      transition: 0.3s;
      border-radius: 24px;
    }
    .slider:before {
      position: absolute;
      content: "";
      height: 18px; width: 18px;
      left: 3px; bottom: 3px;
      background-color: white;
      transition: 0.3s;
      border-radius: 50%;
    }
    input:checked + .slider {
      background-color: #00aaff;
      box-shadow: 0 0 10px #00aaff;
    }
    input:checked + .slider:before {
      transform: translateX(20px);
    }
    button {
      margin-top:10px;width:100%;
      padding:7px;background:#00aaff;
      color:white;border:none;border-radius:5px;
      cursor:pointer;font-weight:bold;
    }
  </style>
</head>
<body>
  <div id="info">
    <h3>üí† M√¥ h√¨nh 3D - THCS</h3>
    <label>Ch·ªçn h√¨nh:</label>
    <select id="shape">
      <option value="box">H·ªôp ch·ªØ nh·∫≠t</option>
      <option value="cube">H√¨nh l·∫≠p ph∆∞∆°ng</option>
      <option value="cylinder">H√¨nh tr·ª•</option>
      <option value="sphere">H√¨nh c·∫ßu</option>
      <option value="pyramid">Ch√≥p t·ª© gi√°c ƒë·ªÅu</option>
    </select>

    <label>C·∫°nh a / B√°n k√≠nh (r):</label><input type="number" id="a" value="3" step="0.1">
    <label>C·∫°nh b:</label><input type="number" id="b" value="4" step="0.1">
    <label>Chi·ªÅu cao (h):</label><input type="number" id="c" value="5" step="0.1">

    <br><br>
    <label>üî¢ Hi·ªán k√≠ch th∆∞·ªõc:
      <label class="switch">
        <input type="checkbox" id="dimToggle" onchange="toggleDimensions()">
        <span class="slider"></span>
      </label>
    </label>
    <label>üí° Ch·ªâ hi·ªÉn th·ªã c·∫°nh:
      <label class="switch">
        <input type="checkbox" id="wireToggle" onchange="toggleWireframe()">
        <span class="slider"></span>
      </label>
    </label>

    <button onclick="drawShape()">V·∫Ω & T√≠nh to√°n</button>
    <button style="margin-top:8px;width:100%;padding:7px;background:#ff3366;color:white;border:none;border-radius:5px;cursor:pointer;"onclick="window.location.href='ai-chat.html'">üí¨ Chat v·ªõi AI</button>

    <div id="output" style="margin-top:10px;font-size:13px;line-height:1.4;"></div>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/three@0.125.2/build/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.125.2/examples/js/controls/OrbitControls.js"></script>

  <script>
    let scene, camera, renderer, controls, grid;
    let mesh, dimensionGroup, wireframeMesh;

    scene = new THREE.Scene();
    scene.background = new THREE.Color(0x000000);
    camera = new THREE.PerspectiveCamera(45, window.innerWidth/window.innerHeight, 0.1, 1000);
    camera.position.set(8, 8, 10);
    renderer = new THREE.WebGLRenderer({antialias:true});
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    controls = new THREE.OrbitControls(camera, renderer.domElement);
    scene.add(new THREE.AmbientLight(0xffffff, 0.7));
    const light = new THREE.PointLight(0xffffff, 1);
    light.position.set(10,10,10);
    scene.add(light);

    function resetGrid(size=20) {
      if (grid) scene.remove(grid);
      grid = new THREE.GridHelper(size, size, 0x333333, 0x111111);
      scene.add(grid);
    }
    resetGrid();

    // === H√†m ch√≠nh v·∫Ω ===
    function drawShape() {
      const type = document.getElementById("shape").value;
      const a = parseFloat(document.getElementById("a").value);
      const b = parseFloat(document.getElementById("b").value);
      const c = parseFloat(document.getElementById("c").value);

      if (mesh) scene.remove(mesh);
      if (dimensionGroup) scene.remove(dimensionGroup);
      if (wireframeMesh) scene.remove(wireframeMesh);

      let geo, stp, sxq, v;

      switch (type) {
        case "box":
          geo = new THREE.BoxGeometry(a, c, b);
          sxq = 2 * c * (a + b);
          stp = 2 * (a*b + a*c + b*c);
          v = a*b*c;
          break;
        case "cube":
          geo = new THREE.BoxGeometry(a, a, a);
          sxq = 4*a*a;
          stp = 6*a*a;
          v = a*a*a;
          break;
        case "cylinder":
          geo = new THREE.CylinderGeometry(a, a, c, 32);
          sxq = 2*Math.PI*a*c;
          stp = sxq + 2*Math.PI*a*a;
          v = Math.PI*a*a*c;
          break;
        case "sphere":
          geo = new THREE.SphereGeometry(a, 32, 32);
          sxq = 0;
          stp = 4*Math.PI*a*a;
          v = (4/3)*Math.PI*a*a*a;
          break;
        case "pyramid":
          geo = new THREE.ConeGeometry(a, c, 4);
          const slant = Math.sqrt((a)**2 + (c)**2);
          sxq = 2*a*slant;
          stp = sxq + a*a;
          v = (1/3)*a*a*c;
          break;
      }

      resetGrid(Math.max(a,b,c)*4);

      const mat = new THREE.MeshStandardMaterial({
        color: 0x0066ff,
        roughness: 0.3,
        metalness: 0.2,
        opacity: 0.9,
        transparent: true
      });
      mesh = new THREE.Mesh(geo, mat);

      geo.computeBoundingBox();
      const yMin = geo.boundingBox.min.y;
      mesh.position.y = -yMin;
      scene.add(mesh);

      document.getElementById("output").innerHTML = `
        <b>K·∫øt qu·∫£:</b><br>
        Di·ªán t√≠ch xung quanh: ${sxq.toFixed(2)}<br>
        Di·ªán t√≠ch to√†n ph·∫ßn: ${stp.toFixed(2)}<br>
        Th·ªÉ t√≠ch: ${v.toFixed(2)}
      `;
    }

    function makeTextSprite(message) {
      const canvas = document.createElement('canvas');
      const ctx = canvas.getContext('2d');
      ctx.font = "bold 150px Arial";
      ctx.shadowColor = "#fff";
      ctx.shadowBlur = 25;
      ctx.fillStyle = "#fff";
      ctx.fillText(message, 0, 150);
      const texture = new THREE.Texture(canvas);
      texture.needsUpdate = true;
      const material = new THREE.SpriteMaterial({ map: texture, transparent: true });
      const sprite = new THREE.Sprite(material);
      sprite.scale.set(1.5, 0.8, 1);
      return sprite;
    }

function createDimensionLine(start, end, label) {
  // H∆∞·ªõng c·∫°nh
  const dir = new THREE.Vector3().subVectors(end, start).normalize();

  // Ch·ªçn vector "up" tr√°nh tr√πng h∆∞·ªõng ƒë·ªÉ t√≠nh offset ƒë√∫ng
  let up;
  if (Math.abs(dir.y) > 0.9) {
    up = new THREE.Vector3(1, 0, 0); // c·∫°nh d·ªçc
  } else if (Math.abs(dir.z) > 0.9) {
    up = new THREE.Vector3(0, -0.2, 0); // c·∫°nh song song tr·ª•c Z
  } else {
    up = new THREE.Vector3(0, 1, ); // c·∫°nh song song X
  }

  // Offset ƒë·∫©y ra ngo√†i h√¨nh (0.7 = kho·∫£ng c√°ch)
  const offset = dir.clone().cross(up).normalize().multiplyScalar(0.8);

  // D·ªãch c·∫£ ƒë∆∞·ªùng ƒëo ra ngo√†i h√¨nh
  const s = start.clone().add(offset);
  const e = end.clone().add(offset);

  // V·∫Ω ƒë∆∞·ªùng ƒëo (m√†u xanh neon)
  const lineGeo = new THREE.BufferGeometry().setFromPoints([s, e]);
  const lineMat = new THREE.LineBasicMaterial({ color: 0x0066ff });
  const line = new THREE.Line(lineGeo, lineMat);

  // Chi·ªÅu d√†i m≈©i t√™n
  const len = s.distanceTo(e);
  const arrowSize = Math.min(len * 0.12, 0.4);

  // Hai m≈©i t√™n h∆∞·ªõng ra ngo√†i
  const arrow1 = new THREE.ArrowHelper(
    dir.clone().negate(),
    s.clone().add(dir.clone().multiplyScalar(arrowSize)),
    arrowSize,
    0xff0000,
    0.25,
    0.15
  );
  const arrow2 = new THREE.ArrowHelper(
    dir,
    e.clone().add(dir.clone().negate().multiplyScalar(arrowSize)),
    arrowSize,
    0xff0000,
    0.25,
    0.15
  );

  // Th√™m nh√£n s·ªë ƒëo (m√†u tr·∫Øng)
  const text = makeTextSprite(label.toFixed(2), {
    fontsize: 120,
    color: "#ffffff",
    glow: "#ffffff"
  });
  text.position.copy(s.clone().add(e).multiplyScalar(0.5));
  text.position.add(offset.clone().multiplyScalar(0.4));
  text.position.y += 0.5;

  // Gom nh√≥m
  const g = new THREE.Group();
  g.add(line, arrow1, arrow2, text);
  return g;
}




    function toggleDimensions() {
      const toggle = document.getElementById("dimToggle").checked;
      const type = document.getElementById("shape").value;
      if (!mesh) return;
      if (dimensionGroup) scene.remove(dimensionGroup);

      if (toggle) {
        const a = parseFloat(document.getElementById("a").value);
        const b = parseFloat(document.getElementById("b").value);
        const c = parseFloat(document.getElementById("c").value);
        dimensionGroup = new THREE.Group();

        switch (type) {
          case "box":
            dimensionGroup.add(createDimensionLine(
              new THREE.Vector3(-a/2, 0, b/2),
              new THREE.Vector3(a/2, 0, b/2), a
            ));
            dimensionGroup.add(createDimensionLine(
              new THREE.Vector3(a/2+0.3, 0, -b/2),
              new THREE.Vector3(a/2+0.3, 0, b/2), b
            ));
            dimensionGroup.add(createDimensionLine(
              new THREE.Vector3(-a/2-0.3, 0, -b/2),
              new THREE.Vector3(-a/2-0.3, c, -b/2), c
            ));
            break;
          case "cube":
            dimensionGroup.add(createDimensionLine(
              new THREE.Vector3(-a/2, 0, b/2),
              new THREE.Vector3(a/2, 0, b/2), a
            ));
            break;

          case "cylinder":
            dimensionGroup.add(createDimensionLine(
              new THREE.Vector3(0, 0, 0),
              new THREE.Vector3(a, 0, 0), a
            ));
            dimensionGroup.add(createDimensionLine(
              new THREE.Vector3(a+0.4, 0, 0),
              new THREE.Vector3(a+0.4, c, 0), c
            ));
            break;

          case "sphere":
            dimensionGroup.add(createDimensionLine(
              new THREE.Vector3(0, 0, 0),
              new THREE.Vector3(a, 0, 0), a
            ));
            dimensionGroup.add(createDimensionLine(
              new THREE.Vector3(-a, 0, 0),
              new THREE.Vector3(a, 0, 0), 2*a
            ));
            break;

          case "pyramid":
            dimensionGroup.add(createDimensionLine(
              new THREE.Vector3(-a, 0, 0),
              new THREE.Vector3(a, 0, 0), 2*a
            ));
            dimensionGroup.add(createDimensionLine(
              new THREE.Vector3(a+0.4, 0, 0),
              new THREE.Vector3(a+0.4, c, 0), c
            ));
            break;
        }
        scene.add(dimensionGroup);
      }
    }

    function toggleWireframe() {
      const toggle = document.getElementById("wireToggle").checked;
      if (!mesh) return;
      if (toggle) {
        const edges = new THREE.EdgesGeometry(mesh.geometry);
        const mat = new THREE.LineBasicMaterial({ color: 0x00ffff });
        wireframeMesh = new THREE.LineSegments(edges, mat);
        wireframeMesh.position.copy(mesh.position);
        scene.add(wireframeMesh);
        mesh.visible = false;
      } else {
        scene.remove(wireframeMesh);
        mesh.visible = true;
      }
    }

    function animate() {
      requestAnimationFrame(animate);
      controls.update();
      renderer.render(scene, camera);
    }
    animate();

    window.addEventListener("resize", () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });
  </script>
</body>
</html>
